## Как проверять проект

При проверке проекта опирайтесь на:
* Чек-лист в проекте.
* Ссылки на материалы Хекслета на шагах проекта и в чек-листе.
* Практики на Хекслете.
* Этот файл.

Чек-лист проекта содержит подпункт "Порядок проверки", где студенту и наставнику описывается в каком порядке и что проверяется. Общая рекомендация - проверять проект "сверху вниз". Через оформление, тесты (при наличии), точку входа, интерфейсы главных функций. Как только на одном из уровней обнаружены нарушения, проверка останавливается и проект отправляется на доработку. Пока студент исправляет тесты и интерфейсы функций, он всё равно рефакторит код "под капотом", поэтому нет смысла проверять сразу всё или начинать с деталей реализации. При неправильно выстроенной архитектуре, когда проект проще переписать с нуля, то надо начинать рефакторинг с этого. 

Видео и статьи, ссылки на которые находятся в проектах на шагах и в чек-листе также могут быть использованы при ревью. Много разбиралось в докладах "Ментальное программирование" и цикле статей [Совершенный код](https://www.google.com/search?q=site%3Ahexlet.io%2Fblog+"Совершенный+код%3A").

Для некоторых проектов в программе имеются испытания, которые помогают студентам понять, как решать некоторые шаги проекта. Так, для второго проекта "Вычислитель отличий" в каждой программе есть испытания "Вычислитель отличий" и "JSON stringify". Также, практики в уроках так или иначче подводят к решениям, которые будут применяться в проекте. Поэтому если у студента нет выполненных испытаний или низкий процент решений, то подтолкнуть студента к решению можно через практику.

А для всех типовых ситуаций используйте типовые ответы, которые помогут быстро и по делу составлять ревью студенту:


## Логика в бинарниках
Бинарник - это не часть библиотеки, это ее пользователь. Бинарники никогда никуда не импортируются, единственный способ их использования - запуск в командной строке. Отсюда есть несколько следствий. Во-первых невозможно переиспользовать код определенный в бинарнике, потому что это конечная точка, а во вторых это сразу означает что написав там часть логики, вы больше не можете легко тестировать ваш код, потому что вы не можете получить к нему доступ.

Другими словами в бинарнике должен быть вызов интерфейса вашей библиотеки, что, в общем, случае сводится к вызову одной функции.

## Именование
https://ru.hexlet.io/blog/posts/naming-in-programming

## Магические числа
https://refactoring.guru/ru/replace-magic-number-with-symbolic-constant

## Ad-hoc Шебанг
Такой шебанг завязан на локальное окружение, а значит что этот бинарник просто не заработает в чужом окружении. Правильно работать через `env`.

## Дублирование кода
Если вы обнаруживаете, что пишете повторяющийся код, это сигнал о том, что вы что-то делаете не так. Нужно отделить общее от частного и не допускать повторений. Проблема в том, что написание кода - это лишь скромная часть жизненного цикла продукта, и дальнейшее сопровождение кода с дубликатами будет слишком осложнено. Повторяющийся код приводит к  усложнению восприятия кода другими программистами, а внесение изменений в общую логику приводит к тому что приходится править во всех местах, где скопирован код.

## Имена функций
Имя функции должно быть глаголом, она ведь что то делает. https://ru.hexlet.io/blog/posts/naming-in-programming

## Вызовы в модулях (вне функций)
Самая главная ошибка на текущем этапе, в том, что файл библиотеки (не бин!), содержит вызовы на уровне файла! То есть импортировать куда то чтобы протестировать или повызывать отдельные функции этого модуль теперь невозможно.

Это недопустимо для библиотечных файлов. В них должны быть только определения функций/классов.

## Архитектура (brain games)
Если всмотреться в игры то видно, что у них общий флоу (порядок действий). Проект естественным образом распадается на независимые части, первая - игровой процесс, вторая - реализация конкретной игры, в которую входит генерация вопроса, правильного ответа и описания игры. Так появляются барьеры абстракций. Код становится проще, модульнее, проще для тестирования и доработки. Например при создании новой игры нужно будет всего лишь описать логику игры и знать про процесс вообще не обязательно.

Прямо сейчас, я вижу, что каждая  игра кроме своей логики, одновременно реализует и флоу.

## Вложенные определения функций/констант
В модулях, вложенные определения (функций/констант) делаются тогда, когда их содержимое зависит от лексического контекста. Во всех остальных случаях предпочтительно выносить определения на уровень модуля (но не обязательно экспортировать). Такой код легче читать, проще переиспользовать и по необходимости можно экспортировать и тестировать.

Кроме того, определения внутри функции происходят каждый раз при вызове внешней функции.

## Побочные эффекты в играх
Не должно быть в играх побочных эффектов. Представь что в следующий раз мы решим вместо консоли делать вывод в другое место. Такой подход заставит переписывать все игры!

## Предикаты
Функции начинающиеся с `is` это предикаты, другими словами это функции, результатом которых будет либо true, либо false. Возврат других значений приводит к семантическому разрыву и невозможности использования функции вне того кейса, под который была заточена эта функция.

## Фикстуры в тестах
Любые дополнительные файлы используемые в тестах называются фикстуры. Их принято складывать в отдельную папку, лежащую в папке с тестами, например в `__fixtures__`.

## Фикстуры в коде
Такие фикстуры очень сложно поддерживать и анализировать. Их нужно положить в файлы и читать оттуда.

## Выбор действия по условию
Выбор функции для обработки по условию, это яркий пример кода, который нельзя расширять. Единственный способ добавить новое поведение, это залезть в кишки (а надо еще знать где этот код), и изменить его (что нарушает open/close принцип). В жизни бывают ситуации, когда подобных действий десятки и больше, соответственно у вас все было бы в ифах. Это та самая ситуация, где нужен полиморфизм включения, о котором говорилось в курсах.


## Парсинг без побочных эффектов
Парсинг, сам по себе, никак не связан с тем откуда приходят данные, из файла или приходят по сети. Парсинг по своей сути чистая функция – на вход сырые данные, на выходе структура.

## Разница между данными
Когда надо найти разницу между объектами, мы всегда натыкаемся на сложность. Часть ключей есть только в одном объекте часть только в другом. Возникает необходимость обходить каждый объект независимо. Но есть путь лучше, надо просто взять все ключи из первого объекта и объединить (нужно прочитать о том что такое операция union в теории множеств) с ключами из второго. Затем, делая по ним мап, можно определять какое было действие и в зависимости от этого продолжать работу. Для объединения нужно использовать `_.union` из `lodash`.

## Строка с результатом сравнения
Такой код сложно поддерживать и расширять. В будущих шагах он станет значительно сложнее. Лучше положить его в текстовые файлы внутри фикстур и читать в нужном тесте.

## Конкатенация +/-
Такой подход ломает структуру (если раньше в списке на каждый плюс минус приходился один элемент, то теперь в одном из элементов сразу и плюс и минус), если бы тебе понадобилось ее дальше обрабатывать (например выполнить еще один map) то все, не получилось бы.

Прочитайте про flatten (есть в lodash), с его помощью можно сделать так, что структура сохранится и каждый `+` или `-` будет единственным элементом в списке.

## Явное использование undefined вне предикатов
У undefined есть семантика: “не определено”. Когда вы руками его используете, то у вас получается что в явно определенном месте лежит значение "не определено". Это и называется “семантический разрыв”. Соответственно когда вам так хочется сделать, это звоночек, который говорит о том что вы делаете не то.

## Бины пользователи
Любой `bin` не является частью библиотеки, это такой же пользователь, как и тот кто будет устанавливать ваш пакет. Соответственно единственное что может делаться в бинах, это парсинг аргументов и передача их внутрь библиотеки. Только в таком случае будет возможность нормально тестировать и переиспользовать код.

## Побочные эффекты
Главный архитектурный принцип звучит так: Изолируйте побочные эффекты от чистого кода. Соответственно все что связано с вводом/выводом должно быть не внутри, а, желательно, на самом верхнем уровне. Причем, чаще всего, в начале работы программы идет чтение необходимых данных, потом большой блок основной логики (чистый код) и на выходе снова побочный эффект, например, запись в файл.

## Конфигурация библиотеки
Если в проекте присутствует библиотека, которая должна быть преконфигурирована (глобально), то правильно выделить библиотеку  в отдельный файл `src/lib/libname.js` где уже можно делать эту конфигурацию. В дальнейшем весь код должен ходить за этой библиотекой через созданный враппер.

## Промисы vs Колбеки
Промисы придуманы для того чтобы избавиться от callback hell, а в этом коде идет уход от промисов к колбекам.

## Побочные эффекты в файле
Нельзя создавать побочные эффекты на этапе загрузки файла (а файл с тестами это обычный модуль js, который импортируется внутри фреймворка jest). Подчеркну, не на выполнение кода из файла, а именно на загрузку (то есть когда тестовый фреймворк импортирует этот модуль). Все действия должны происходить внутри функций.

## Печать в консоль внутри библиотеки
Нельзя писать в консоль внутри библиотеки, это прерогатива вызывающего кода. Вдруг мы захотим у себя эту штуку напрямую использовать? И как нам поможет такая ошибка в коде? Мы ее обработать даже не сможем, не говоря уже о том что вызываться эта библиотека может в абсолютно любом контексте, даже в таком в котором нельзя просто так писать в консоль (например в системе своя система логирования).

## Вложенные промисы
Цель использования промисов это выпрямление потока выполнения программы. Нужно избавляться от вложенности.

## Артефакты
это артефакты сборки, а не часть исходного кода. Их нельзя коммитить.

## Секреты
Секреты можно устанавливать только через переменные окружения. Нельзя чтобы они попадали в репозиторий. В nodejs это удобно делать с помощью пакета dotenv.

## Ссылки
Генерация ссылок вручную, это не только постоянное дублирование, но также и отсутствие какой либо верификации. Изменение роута поломает пол сайта и даже тесты не смогут этого показать.  Я уже не говорю про то что при любых изменениях надо будет переписывать очень много мест.

Посмотри на `index.js` там есть такая строчка `{ urlFor: (...args) => router.url(...args) },`
